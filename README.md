# ИИ-Агент Поддержки Директоров Магазинов (Telegram)

Этот проект представляет собой ИИ-агента, работающего через Telegram и предназначенного для оказания поддержки директорам магазинов доставки еды. Агент помогает обрабатывать инциденты, связанные с поведением курьеров, основываясь на должностных инструкциях и методических рекомендациях.

## Как это работает: Сценарии использования

Агент построен на мультиагентной архитектуре с использованием Langchain и OpenAI. Основной процесс включает сбор информации и принятие решений.

### Сценарий 1: Директор сообщает о пьяном курьере

1.  **Директор начинает диалог:**
    ```
    Директор: Привет
    Агент: Здравствуйте! Как я могу вам помочь сегодня? Если у вас есть жалоба или вопрос, пожалуйста, дайте мне знать.
    ```

2.  **Директор описывает проблему:**
    ```
    Директор: Курьер Иван Сидоров пришел на работу пьяный. Я с центрального склада.
    Агент: Понял вас. Уточните, пожалуйста, ID курьера Ивана Сидорова, если знаете. И когда именно произошел инцидент?
    ```
    *   **За кулисами:** Агент-Сборщик Информации (`InformationCollectorAgent`) пытается определить склад по логину директора (если не указан явно), ищет курьера по ФИО.

3.  **Директор предоставляет детали:**
    ```
    Директор: ID 123. Это было только что.
    Агент: Спасибо, информация собрана. Анализирую и принимаю решение...
    ```
    *   **За кулисами:** Агент-Сборщик Информации запрашивает у RAG-модуля (в текущей версии - заглушка) релевантные выдержки из инструкций по поводу "пьяного курьера". Собрав все данные (ID курьера, ФИО, склад, описание инцидента, время, выдержки из инструкций), он передает их Агенту-Принятия Решений.

4.  **Агент выносит решение:**
    ```
    Агент: По инциденту с курьером Ивановым Иваном Ивановичем (ID: 123), который пришел на работу в нетрезвом виде на Центральном складе, было принято решение о его немедленной блокировке и удалении текущей смены. Это соответствует методическим рекомендациям (раздел 'Критические нарушения'). Курьер успешно заблокирован, активных смен для удаления не найдено.
    ```
    *   **За кулисами:** Агент-Принятия Решений (`DecisionMakerAgent`) анализирует полученные данные и выдержки из инструкций. На их основе он выбирает соответствующее действие (например, `ban_courier`) и вызывает соответствующий инструмент (`take_action_on_courier`). Затем формулирует ответ директору.

### Сценарий 2: Курьер не вышел на смену

1.  **Директор сообщает о невыходе:**
    ```
    Директор: Курьер Петров Петр (ID 456) не вышел сегодня на утреннюю смену на Северном филиале и не предупредил.
    Агент: Спасибо, информация собрана. Анализирую и принимаю решение...
    ```
    *   **За кулисами:** Агент-Сборщик Информации идентифицирует курьера, склад, суть проблемы. Запрашивает у RAG-модуля инструкции по "невыходу на смену".

2.  **Агент выносит решение:**
    ```
    Агент: По ситуации с курьером Петровым Петром Петровичем (ID: 456), который не вышел на смену на Северном филиале без предупреждения, принято решение: текущая смена удалена, зарегистрирована жалоба (1-й страйк). Это соответствует методическим рекомендациям при первом невыходе без предупреждения.
    ```
    *   **За кулисами:** Агент-Принятия Решений на основе инструкций из RAG (например, "1-й невыход - удалить смену, страйк") вызывает инструменты `delete_shift` и `log_complaint`.

## Техническое описание

Система состоит из нескольких ключевых компонентов:

### 1. Конфигурация (`config.py`)
   - Загружает переменные окружения (API ключи, URL для RAG) из файла `.env`.

### 2. Инструменты (`tools/`)
   Модули, предоставляющие агентам доступ к внешним системам или данным.

   - **`courier_api.py`**:
     - `search_courier_by_id_or_name(identifier: str)`: Имитирует поиск курьера в базе данных по ID или ФИО.
     - `get_shifts_by_warehouse_id(warehouse_id: str)`: Имитирует получение списка смен для склада.
     - Содержит моковые базы `MOCK_COURIERS_DB` и `MOCK_SHIFTS_DB`.

   - **`warehouse_api.py`**:
     - `get_warehouse_by_director_login(director_login: str)`: Имитирует определение склада по логину директора.
     - Содержит моковую базу `MOCK_DIRECTORS_DB`.

   - **`decision_actions.py`**:
     - `take_action_on_courier(...)`: Имитирует выполнение действий над курьером (удаление смены, бан, запись жалобы), изменяя данные в моковых базах.

   - **`rag_client.py`**:
     - `query_rag_service(query_text: str, top_k: int)`: Асинхронная функция для запроса к RAG-сервису. В текущей версии имеет встроенную заглушку (`USE_RAG_MOCK = True`), возвращающую предопределенные тексты инструкций на основе ключевых слов в запросе. Если `USE_RAG_MOCK = False` и `RAG_API_URL` задан, пытается обратиться к реальному RAG-сервису.

   - **`tool_definitions.py`**:
     - Определяет Pydantic модели для валидации аргументов инструментов (`SearchCourierInput`, `GetWarehouseInput`, `TakeActionInput`, `QueryRAGInput`).
     - Создает экземпляры инструментов Langchain:
       - `search_courier_tool`: На основе `search_courier_by_id_or_name`.
       - `get_warehouse_tool`: На основе `get_warehouse_by_director_login`.
       - `take_action_tool`: Экземпляр кастомного класса `TakeActionTool(BaseTool)`, который оборачивает `take_action_on_courier` для корректной обработки именованных аргументов.
       - `query_rag_tool`: На основе асинхронной обертки `_query_rag_service_wrapper` для `query_rag_service`, обеспечивающей гибкую передачу аргументов.
     - Группирует инструменты в списки `collector_tools` и `decision_tools` для соответствующих агентов.

### 3. Агенты (`agents/`)
   Логические единицы, выполняющие определенные задачи.

   - **`information_collector_agent.py`**:
     - `COLLECTOR_SYSTEM_PROMPT`: Системный промпт, описывающий задачи агента по сбору информации.
     - `collector_prompt`: `ChatPromptTemplate` на основе системного промпта.
     - `collector_agent_runnable`: Агент, созданный с помощью `create_openai_functions_agent`.
     - `collector_agent_executor`: `AgentExecutor` для запуска агента с `collector_tools`.
     - `run_information_collector(...)`: Асинхронная функция, управляющая запуском агента, обработкой его ответа и извлечением собранных данных в формате JSON.

   - **`decision_maker_agent.py`**:
     - `DECISION_MAKER_SYSTEM_PROMPT`: Системный промпт, описывающий задачи агента по анализу информации и принятию решений на основе инструкций.
     - `decision_prompt`: `ChatPromptTemplate` на основе системного промпта.
     - `decision_agent_runnable`: Агент, созданный с помощью `create_openai_functions_agent`.
     - `decision_agent_executor`: `AgentExecutor` для запуска агента с `decision_tools`.
     - `run_decision_maker(...)`: Асинхронная функция, принимающая собранные данные, запускающая агента и возвращающая его финальный ответ.

### 4. Основной модуль бота (`main_bot.py`)
   - Инициализирует Telegram-бота с использованием `aiogram`.
   - Настраивает логирование.
   - Управляет состоянием диалога (FSM) для хранения истории чата (`CHAT_HISTORY_KEY`).
   - `command_start_handler`: Обрабатывает команду `/start`.
   - `handle_text_message`: Основной обработчик текстовых сообщений:
     - Получает сообщение пользователя и историю чата.
     - Вызывает `run_information_collector`.
     - Если информация собрана (`status: "completed"`), вызывает `run_decision_maker`.
     - Отправляет ответы агентов пользователю.
     - Обновляет историю чата.
   - `main()`: Асинхронная функция для запуска поллинга бота.

## Запуск проекта

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <URL_вашего_репозитория>
    cd <название_папки_проекта>
    ```

2.  **Создайте и активируйте виртуальное окружение:**
    ```bash
    python -m venv .venv
    source .venv/bin/activate  # для Linux/macOS
    # .venv\Scripts\activate    # для Windows
    ```

3.  **Установите зависимости:**
    Создайте файл `requirements.txt` со следующим содержимым:
    ```txt
    python-dotenv
    langchain
    langchain-openai
    httpx
    aiogram>=3.0.0
    # Если вы используете pywebpush для чего-то другого, добавьте его
    # pywebpush 
    ```
    Затем выполните:
    ```bash
    pip install -r requirements.txt
    ```

4.  **Создайте файл `.env`:**
    В корневой директории проекта создайте файл `.env` и добавьте в него ваши API ключи:
    ```env
    OPENAI_API_KEY="sk-your_openai_api_key"
    TELEGRAM_BOT_TOKEN="your_telegram_bot_token"
    # RAG_API_URL="http://localhost:8001/retrieve" # Закомментировано, т.к. по умолчанию None и используется мок
    ```
    - Замените `sk-your_openai_api_key` на ваш ключ OpenAI.
    - Замените `your_telegram_bot_token` на токен вашего Telegram-бота (полученный от @BotFather).
    - `RAG_API_URL` можно оставить закомментированным или не указывать, если вы хотите использовать встроенную RAG-заглушку. Если у вас есть реальный RAG-сервис, укажите его URL.

5.  **Запустите RAG-сервис (если не используется заглушка):**
    Если `USE_RAG_MOCK` в `tools/rag_client.py` установлено в `False` и вы указали `RAG_API_URL`, убедитесь, что ваш RAG-сервис запущен и доступен по этому URL.

6.  **Запустите бота:**
    ```bash
    python main_bot.py
    ```

7.  **Начните диалог с ботом в Telegram.**

## Возможные доработки

-   Реализация полноценного RAG-сервиса вместо заглушки.
-   Расширение набора инструкций и методических рекомендаций.
-   Добавление более сложных сценариев обработки инцидентов.
-   Интеграция с реальными базами данных курьеров и смен.
-   Улучшение обработки ошибок и пользовательского опыта.
-   Добавление возможности для директоров предоставлять фото/видео доказательства.